
{
  "entities": {
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user of the CreatorX SEO platform.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the User entity."
        },
        "email": {
          "type": "string",
          "description": "User's email address.",
          "format": "email"
        },
        "firstName": {
          "type": "string",
          "description": "User's first name."
        },
        "lastName": {
          "type": "string",
          "description": "User's last name."
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp of when the user account was created.",
          "format": "date-time"
        },
        "updatedAt": {
          "type": "string",
          "description": "Timestamp of when the user account was last updated.",
          "format": "date-time"
        },
        "subscriptionId": {
          "type": "string",
          "description": "Reference to Subscription. (Relationship: User 1:1 Subscription)"
        },
        "plan": {
          "type": "string",
          "description": "The user's current subscription plan.",
          "enum": ["free", "starter", "pro"]
        }
      },
      "required": [
        "id",
        "email",
        "firstName",
        "lastName",
        "createdAt",
        "updatedAt"
      ]
    },
    "ChannelAccount": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ChannelAccount",
      "type": "object",
      "description": "Represents a YouTube channel or Instagram account linked to a user.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the ChannelAccount entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N ChannelAccount)"
        },
        "platform": {
          "type": "string",
          "description": "The platform of the channel/account (e.g., YouTube, Instagram)."
        },
        "channelId": {
          "type": "string",
          "description": "The unique channel ID provided by the platform."
        },
        "displayName": {
          "type": "string",
          "description": "The display name of the channel/account."
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp of when the channel/account was linked.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "userId",
        "platform",
        "channelId",
        "displayName",
        "createdAt"
      ]
    },
    "ContentIdea": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ContentIdea",
      "type": "object",
      "description": "Represents a content idea generated by the platform.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the ContentIdea entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N ContentIdea)"
        },
        "category": {
          "type": "string",
          "description": "The category of the content idea."
        },
        "title": {
          "type": "string",
          "description": "The title of the content idea."
        },
        "description": {
          "type": "string",
          "description": "A short description of the content idea."
        },
        "keywords": {
          "type": "array",
          "description": "Keywords associated with this content idea",
          "items": {
            "type": "string"
          }
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp of when the content idea was generated.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "userId",
        "category",
        "title",
        "description",
        "keywords",
        "createdAt"
      ]
    },
    "Keyword": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Keyword",
      "type": "object",
      "description": "Represents a keyword used for SEO research.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Keyword entity."
        },
        "keyword": {
          "type": "string",
          "description": "The keyword itself."
        },
        "searchVolume": {
          "type": "number",
          "description": "The monthly search volume for the keyword."
        },
        "difficultyScore": {
          "type": "number",
          "description": "The difficulty score for ranking for the keyword."
        },
        "trendData": {
          "type": "string",
          "description": "Trend data for the keyword (e.g., JSON string of monthly search volume)."
        }
      },
      "required": [
        "id",
        "keyword",
        "searchVolume",
        "difficultyScore",
        "trendData"
      ]
    },
    "Competitor": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Competitor",
      "type": "object",
      "description": "Represents a competitor channel or video.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Competitor entity."
        },
        "url": {
          "type": "string",
          "description": "The URL of the competitor channel or video.",
          "format": "uri"
        },
        "channelName": {
          "type": "string",
          "description": "The name of the competitor's channel."
        },
        "avgWatchTime": {
          "type": "number",
          "description": "The average watch time of the competitor's videos."
        },
        "commonTags": {
          "type": "array",
          "description": "Common tags used by the competitor.",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "id",
        "url",
        "channelName",
        "avgWatchTime",
        "commonTags"
      ]
    },
    "VideoMetrics": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "VideoMetrics",
      "type": "object",
      "description": "Represents metrics for a specific video.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the VideoMetrics entity."
        },
        "channelAccountId": {
          "type": "string",
          "description": "Reference to ChannelAccount. (Relationship: ChannelAccount 1:N VideoMetrics)"
        },
        "videoId": {
          "type": "string",
          "description": "The ID of the video on the platform (e.g., YouTube video ID)."
        },
        "impressions": {
          "type": "number",
          "description": "The number of impressions for the video."
        },
        "ctr": {
          "type": "number",
          "description": "The click-through rate for the video."
        },
        "watchTime": {
          "type": "number",
          "description": "The total watch time for the video (in seconds)."
        },
        "engagementRate": {
          "type": "number",
          "description": "The engagement rate for the video."
        },
        "rankPositions": {
          "type": "string",
          "description": "Ranking positions of the video for tracked keywords (e.g., JSON string of keyword:position pairs)."
        },
        "recordedAt": {
          "type": "string",
          "description": "Timestamp of when these metrics where recorded.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "channelAccountId",
        "videoId",
        "impressions",
        "ctr",
        "watchTime",
        "engagementRate",
        "rankPositions",
        "recordedAt"
      ]
    },
    "TrendEvent": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "TrendEvent",
      "type": "object",
      "description": "Represents a trending event or topic.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the TrendEvent entity."
        },
        "topic": {
          "type": "string",
          "description": "The topic of the trending event."
        },
        "startTime": {
          "type": "string",
          "description": "The start time of the trending event.",
          "format": "date-time"
        },
        "endTime": {
          "type": "string",
          "description": "The end time of the trending event (if applicable).",
          "format": "date-time"
        },
        "relatedKeywords": {
          "type": "array",
          "description": "Keywords related to the trending event.",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "id",
        "topic",
        "startTime",
        "relatedKeywords"
      ]
    },
    "Subscription": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Subscription",
      "type": "object",
      "description": "Represents a user's subscription plan.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Subscription entity."
        },
        "planName": {
          "type": "string",
          "description": "The name of the subscription plan (e.g., Free, Premium Monthly, Premium Annual)."
        },
        "startDate": {
          "type": "string",
          "description": "The start date of the subscription.",
          "format": "date-time"
        },
        "endDate": {
          "type": "string",
          "description": "The end date of the subscription.",
          "format": "date-time"
        },
        "status": {
          "type": "string",
          "description": "The status of the subscription (e.g., active, cancelled)."
        }
      },
      "required": [
        "id",
        "planName",
        "startDate",
        "endDate",
        "status"
      ]
    },
    "WhatsAppSession": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "WhatsAppSession",
      "type": "object",
      "description": "Represents a WhatsApp session for personalized guidance.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the WhatsAppSession entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N WhatsAppSession)"
        },
        "sessionId": {
          "type": "string",
          "description": "The unique session ID provided by the WhatsApp Business API."
        },
        "startTime": {
          "type": "string",
          "description": "The start time of the WhatsApp session.",
          "format": "date-time"
        },
        "endTime": {
          "type": "string",
          "description": "The end time of the WhatsApp session (if applicable).",
          "format": "date-time"
        },
        "messages": {
          "type": "array",
          "description": "A log of messages exchanged during the WhatsApp session (e.g., JSON string of message objects).",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "id",
        "userId",
        "sessionId",
        "startTime"
      ]
    },
    "BlogPost": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "BlogPost",
      "type": "object",
      "description": "Represents a single blog post.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the BlogPost entity."
        },
        "slug": {
          "type": "string",
          "description": "URL-friendly slug for the blog post."
        },
        "title": {
          "type": "string",
          "description": "The title of the blog post."
        },
        "content": {
          "type": "string",
          "description": "The full content of the blog post, likely in Markdown or HTML."
        },
        "authorId": {
          "type": "string",
          "description": "Reference to the User who wrote the post."
        },
        "coverImageUrl": {
          "type": "string",
          "format": "uri",
          "description": "URL for the blog post's cover image."
        },
        "tags": {
          "type": "array",
          "items": { "type": "string" },
          "description": "A list of tags for categorizing the post."
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp of when the post was created."
        },
        "updatedAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp of when the post was last updated."
        },
        "commenters": {
            "type": "array",
            "items": { "type": "string" },
            "description": "A list of user IDs who have commented on the post."
        }
      },
      "required": ["id", "slug", "title", "content", "authorId", "createdAt", "updatedAt"]
    },
    "BlogComment": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "BlogComment",
      "type": "object",
      "description": "Represents a comment on a blog post.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the BlogComment entity."
        },
        "postId": {
          "type": "string",
          "description": "Reference to the BlogPost this comment belongs to."
        },
        "userId": {
          "type": "string",
          "description": "Reference to the User who wrote the comment."
        },
        "userName": {
          "type": "string",
          "description": "The display name of the user at the time of commenting."
        },
        "userAvatar": {
          "type": "string",
          "format": "uri",
          "description": "A URL to the user's avatar at the time of commenting."
        },
        "content": {
          "type": "string",
          "description": "The content of the comment."
        },
        "createdAt": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp of when the comment was created."
        }
      },
      "required": ["id", "postId", "userId", "userName", "content", "createdAt"]
    }
  },
  "auth": {
    "providers": [
      "password"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user profiles.  All user-owned data is stored under this path to simplify ownership checks. userId is request.auth.uid.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/channelAccounts/{channelAccountId}",
        "definition": {
          "entityName": "ChannelAccount",
          "schema": {
            "$ref": "#/backend/entities/ChannelAccount"
          },
          "description": "Stores channel accounts associated with a user.  Path-based ownership enables simple security rules.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            },
            {
              "name": "channelAccountId",
              "description": "The unique identifier of the channel account."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/contentIdeas/{contentIdeaId}",
        "definition": {
          "entityName": "ContentIdea",
          "schema": {
            "$ref": "#/backend/entities/ContentIdea"
          },
          "description": "Stores content ideas generated by a user. Path-based ownership enables simple security rules.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            },
            {
              "name": "contentIdeaId",
              "description": "The unique identifier of the content idea."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/whatsAppSessions/{sessionId}",
        "definition": {
          "entityName": "WhatsAppSession",
          "schema": {
            "$ref": "#/backend/entities/WhatsAppSession"
          },
          "description": "Stores WhatsApp session data for a user. Path-based ownership enables simple security rules.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            },
            {
              "name": "sessionId",
              "description": "The unique identifier of the WhatsApp session."
            }
          ]
        }
      },
      {
        "path": "/channelAccounts/{channelAccountId}/videoMetrics/{videoMetricsId}",
        "definition": {
          "entityName": "VideoMetrics",
          "schema": {
            "$ref": "#/backend/entities/VideoMetrics"
          },
          "description": "Stores video metrics associated with a channel account.",
          "params": [
            {
              "name": "channelAccountId",
              "description": "The unique identifier of the channel account."
            },
            {
              "name": "videoMetricsId",
              "description": "The unique identifier of the video metrics."
            }
          ]
        }
      },
      {
        "path": "/trendEvents/{trendEventId}",
        "definition": {
          "entityName": "TrendEvent",
          "schema": {
            "$ref": "#/backend/entities/TrendEvent"
          },
          "description": "Stores trending events. Public read access is assumed.",
          "params": [
            {
              "name": "trendEventId",
              "description": "The unique identifier of the trend event."
            }
          ]
        }
      },
      {
        "path": "/subscriptions/{subscriptionId}",
        "definition": {
          "entityName": "Subscription",
          "schema": {
            "$ref": "#/backend/entities/Subscription"
          },
          "description": "Stores subscription data.",
          "params": [
            {
              "name": "subscriptionId",
              "description": "The unique identifier of the subscription."
            }
          ]
        }
      },
      {
        "path": "/keywords/{keywordId}",
        "definition": {
          "entityName": "Keyword",
          "schema": {
            "$ref": "#/backend/entities/Keyword"
          },
          "description": "Stores keyword data. Public read access is assumed.",
          "params": [
            {
              "name": "keywordId",
              "description": "The unique identifier of the keyword."
            }
          ]
        }
      },
      {
        "path": "/competitors/{competitorId}",
        "definition": {
          "entityName": "Competitor",
          "schema": {
            "$ref": "#/backend/entities/Competitor"
          },
          "description": "Stores competitor data. Public read access is assumed.",
          "params": [
            {
              "name": "competitorId",
              "description": "The unique identifier of the competitor."
            }
          ]
        }
      },
      {
        "path": "/blogPosts/{postId}",
        "definition": {
          "entityName": "BlogPost",
          "schema": { "$ref": "#/backend/entities/BlogPost" },
          "description": "Stores individual blog post documents. Publicly readable.",
          "params": [
            { "name": "postId", "description": "The unique identifier for the blog post." }
          ]
        }
      },
      {
        "path": "/blogPosts/{postId}/comments/{commentId}",
        "definition": {
          "entityName": "BlogComment",
          "schema": { "$ref": "#/backend/entities/BlogComment" },
          "description": "Stores comments for a specific blog post. Publicly readable, but only authenticated users can write.",
          "params": [
            { "name": "postId", "description": "The ID of the parent blog post." },
            { "name": "commentId", "description": "The unique identifier for the comment." }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure prioritizes authorization independence and QAPs (Rules are not Filters). User-owned data (ChannelAccounts, ContentIdeas, WhatsAppSessions) are stored under `/users/{userId}` to simplify ownership-based security rules. This eliminates the need for complex `get()` calls in security rules and enables atomic operations.  Subscriptions are stored in a top-level collection to support global queries and simplify subscription-based feature gating. The new blog structure includes a top-level `blogPosts` collection for easy querying of all posts, which is publicly readable. Comments are stored in a subcollection under each post (`/blogPosts/{postId}/comments/{commentId}`) to logically group them and allow for efficient, paginated loading while still enabling straightforward security rules (e.g., anyone can read comments for a post, but only logged-in users can create them).\n\nAuthorization Independence is achieved via path-based ownership for private user data. For example, content ideas are stored under `/users/{userId}/contentIdeas/{contentIdeaId}` which allows security rules to simply check `request.auth.uid == userId`. No data needs to be read to determine authorization.  No membership maps are required as all user-owned data follows the `/users/{userId}` structure. All collections of user data leverage path-based ownership, ensuring authorization rules can be written based solely on the path and `request.auth.uid`.\n\nQAPs are supported via structural segregation. Public data (TrendEvents, Keywords, Competitors, BlogPosts, BlogComments) is stored in top-level collections, allowing secure list operations without complex filtering logic in security rules. User-specific data is segregated under the `/users/{userId}` path, enabling secure listing of user-owned entities."
  }
}
